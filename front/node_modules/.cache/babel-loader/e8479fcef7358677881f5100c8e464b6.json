{"ast":null,"code":"import getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n/**\n *\n */\n\n\nfunction flip({\n  state,\n  options,\n  name\n}) {\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = true,\n    fallbackPlacements: specifiedFallbackPlacements,\n    padding,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    flipVariations = true,\n    allowedAutoPlacements\n  } = options;\n  const preferredPlacement = state.options.placement;\n  const basePlacement = getBasePlacement(preferredPlacement);\n  const isBasePlacement = basePlacement === preferredPlacement;\n  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  const placements = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n    placement,\n    boundary,\n    rootBoundary,\n    padding,\n    flipVariations,\n    allowedAutoPlacements\n  }) : placement), []);\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const checksMap = new Map();\n  let makeFallbackChecks = true;\n  let firstFittingPlacement = placements[0];\n\n  for (let i = 0; i < placements.length; i++) {\n    const placement = placements[i];\n    const basePlacement = getBasePlacement(placement);\n    const isStartVariation = getVariation(placement) === start;\n    const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'width' : 'height';\n    const overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    const altVariationSide = getOppositePlacement(mainVariationSide);\n    const checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(check => check)) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    const numberOfChecks = flipVariations ? 3 : 1;\n\n    for (let i = numberOfChecks; i > 0; i--) {\n      const fittingPlacement = placements.find(placement => {\n        const checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, i).every(check => check);\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        break;\n      }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","map":{"version":3,"sources":["../../../../../../../src/helpers/Popper/thirdparty/popper-core/modifiers/flip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\n/**\n *\n */\nfunction flip({ state, options, name }) {\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements } = options;\n    const preferredPlacement = state.options.placement;\n    const basePlacement = getBasePlacement(preferredPlacement);\n    const isBasePlacement = basePlacement === preferredPlacement;\n    const fallbackPlacements = specifiedFallbackPlacements ||\n        (isBasePlacement || !flipVariations\n            ? [getOppositePlacement(preferredPlacement)]\n            : getExpandedFallbackPlacements(preferredPlacement));\n    const placements = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto\n        ? computeAutoPlacement(state, {\n            placement,\n            boundary,\n            rootBoundary,\n            padding,\n            flipVariations,\n            allowedAutoPlacements\n        })\n        : placement), []);\n    const referenceRect = state.rects.reference;\n    const popperRect = state.rects.popper;\n    const checksMap = new Map();\n    let makeFallbackChecks = true;\n    let firstFittingPlacement = placements[0];\n    for (let i = 0; i < placements.length; i++) {\n        const placement = placements[i];\n        const basePlacement = getBasePlacement(placement);\n        const isStartVariation = getVariation(placement) === start;\n        const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n        const len = isVertical ? 'width' : 'height';\n        const overflow = detectOverflow(state, {\n            placement,\n            boundary,\n            rootBoundary,\n            altBoundary,\n            padding\n        });\n        let mainVariationSide = isVertical ? (isStartVariation ? right : left) : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        const altVariationSide = getOppositePlacement(mainVariationSide);\n        const checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(check => check)) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        const numberOfChecks = flipVariations ? 3 : 1;\n        for (let i = numberOfChecks; i > 0; i--) {\n            const fittingPlacement = placements.find(placement => {\n                const checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, i).every(check => check);\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                break;\n            }\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n}\nexport default {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: { _skip: false }\n};\n//# sourceMappingURL=flip.js.map"]},"metadata":{},"sourceType":"module"}